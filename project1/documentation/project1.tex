\documentclass{scrartcl}
\usepackage{csquotes}
\usepackage[american]{babel}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{svg}
\usepackage{booktabs}
\usepackage{tabulary}
\usepackage{hyperref}
\usepackage{listings}
\setmainfont{Hoefler Text}
\setmonofont{Courier Prime}
\setlength\heavyrulewidth{0.20ex}
\setlength\cmidrulewidth{0.10ex}
\setlength\lightrulewidth{0.10ex}
\hypersetup{
    pdftitle={CMSC 315, Project 1}
    pdfauthor={Alberth Matos}
}
\lstdefinestyle{numberedLines}{
    numbers=left,
    numberstyle=\small,
    stepnumber=1,
    numbersep=5pt,
    frame=none,
    framerule=0.5pt,
    framesep=2pt,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray},
    stringstyle=\color{black},
    showstringspaces=false,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookrightarrow\space}}
}
\lstset{style=numberedLines}
\setcounter{page}{1}
\title{CMSC 315, Project 1}
\author{Alberth Matos}
\date{21 Jan 2026}

\begin{document}
\maketitle
\section{Design}
The goal of the project was to implement a program that checks for balanced
delimiters within a given file, using a stack-based approach to track that
each right-delimiter matched its corresponding left-delimiter. Of note, the
project instructions state the following:
\begin{displayquote}
It should then repeatedly call the method that returns the next character
until it returns a null character indicating the end of the file or until a
mismatch of delimiters is encountered. If the character is a left delimiter
it should be pushed onto a delimiter stack. \emph{If it is a right delimiter, the
stack should be popped and a check should be made to ensure that the
delimiters are of a matching type}. If the delimiters do not match, a message
should be displayed indicating what delimiter was encountered and at what
position.
\end{displayquote}
This can cause confusion when dealing with extraneous delimiters, as the
instructions state that every time a right-delimiter is encountered,
the stack should be popped, removing the last left-delimiter. In the case of
an extraneous right-delimiter, a potentially valid left-delimiter and
right-delimiter pair would not be matched if an extra right-delimiter is
encountered.

The following code snippet illustrates the potential issue:

\begin{lstlisting}[language=Java]
public class badExample {
    ) // Bad delimiter
} // Unmatched good delimiter
\end{lstlisting}

Using this code snippet, following the project requirements as written,
the program will display an error message indicating that an unmatched
right-delimiter was encountered at line 3, position 1. This is actually
incorrect, as the actual problem is that there is an unmatched left-delimiter
at line 2, position 3.

\subsection{UML Diagram}
\includesvg{CheckDelimiters-Class.svg}
\section{Test Plan}
Test Plan:\footnote{Source code files used as test data are provided in
Section \ref{sec:test-data}.}
\begin{enumerate}
    \item Invalid filename provided; program should display an error
    message indicating that the file does not exist, and re-prompt the user
    for a filename.
    \item Valid input with matching delimiters; Several delimiters
    are included in the input file, \emph{goodfile.java}, both inside and outside of
    comments. The program should correctly identify and match all delimiters,
    and not display any error messages.  The program should especially not
    display any error messages related to unmatched delimiters inside of
    comments.
    \item Valid input with mismatched delimiters; a total of
    six (6) mismatched delimiters are included in the input file,
    \emph{badfile1.java}. The program should correctly identify and report
    all mismatched delimiters, and not display any error messages related
    to unmatched delimiters inside of comments.
    \item Valid input, \emph{badfile2.java}, with an extraneous
    left-delimiter, as well as a left-delimiter inside a comment.  The program
    should correctly identify and report the single left-delimiter.
    \item Valid input, \emph{badfile3.java}, with an extraneous
    right-delimiter, as well as a right-delimiter inside a comment.  The
    program should correctly identify and report the bad right-delimiter,
    as well as the right-delimiter that would normally be matched at the end
    of the file.
\end{enumerate}
Test results are displayed in Table \ref{tab:test-plan}.


\begin{table}[h]
\centering
\caption{Test Results}
\begin{tabulary}{1.0\textwidth}{RLL}
\toprule
Test Case & Input & Expected Output \\
\cmidrule(l){1-1} \cmidrule(lr){2-2} \cmidrule(l){3-3}
1 & Invalid filename & Message displays that the file does not exist, and
    re-prompt the user for the filename. \\
\\
2 & Valid input with matching delimiters, file: goodfile.java & No error
message, program completes successfully and displays \enquote{End of file reached.} \\
\\
3 & Invalid input with mismatched left-delimiters, file: badfile1.java &
Program displays error
messages for each mismatched delimiter.\newline
Unmatched right delimiter \enquote*{)} found at line 11, character (index) 41.\newline
Unmatched right delimiter \enquote*{]} found at line 15, character (index) 44.\newline
Unmatched right delimiter \enquote*{]} found at line 26, character (index) 7.\newline
Unmatched right delimiter \enquote*{)} found at line 33, character (index) 3.\newline
Unmatched right delimiter \enquote*{\}} found at line 35, character (index) 3.\newline
Unmatched right delimiter \enquote*{\}} found at line 36, character (index) 1. \\
\\
4 & Invalid input with mismatched right-delimiters, file: badfile2.java &
Program displays error messages for each mismatched delimiter. \newline
Unmatched right delimiter \enquote*{\}} found at line 3, character (index) 1.\\
\\
5 & Invalid input with mismatched right-delimiters, file: badfile3.java &
Program displays error messages for each mismatched delimiter. \newline
Unmatched right delimiter \enquote*{)} found at line 2, character (index) 3.\newline
Unmatched right delimiter \enquote*{\}} found at line 3, character (index) 1.\\
\bottomrule
\end{tabulary}

\label{tab:test-plan}
\end{table}
\section{Lessons Learned}
The single most important lesson learned from the project was the importance
of reading the requirements carefully and thoroughly. When initially
creating the pseudocode framework of the project, this programmer initially
assumed that one should trap each individual delimiter, and not necesserily
pop a left-delimiter off of the stack if the next right-delimiter did not
match. This assumption would have increased the complexity of the code,
and would have discarded one of the requirements of the project, that
each time a right-delimiter was encountered, one \emph{must} pop the
left-delimiter off of the stack.

A second read through the requirements allowed the programmer to catch
this error in understanding, and correct the pseudocode before writing
the actual program.
\section{Test Data}
\label{sec:test-data}

\subsection{goodfile.java}
\lstinputlisting[language=Java]{../testdata/goodfile.java}

\subsection{badfile1.java}
\lstinputlisting[language=Java]{../testdata/badfile1.java}

\subsection{badfile2.java}
\lstinputlisting[language=Java]{../testdata/badfile2.java}

\subsection{badfile3.java}
\lstinputlisting[language=Java]{../testdata/badfile3.java}

\end{document}
