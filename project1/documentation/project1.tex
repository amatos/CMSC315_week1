\documentclass{scrartcl}
\usepackage{csquotes}
\usepackage[american]{babel}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{svg}
\usepackage{booktabs}
\usepackage{tabulary}
\usepackage{hyperref}
\setlength\heavyrulewidth{0.20ex}
\setlength\cmidrulewidth{0.10ex}
\setlength\lightrulewidth{0.10ex}
\hypersetup{
    pdftitle={CMSC 315, Project 1}
    pdfauthor={Alberth Matos}
}
\setcounter{page}{1}
\title{CMSC 315, Project 1}
\author{Alberth Matos}
\date{21 Jan 2026}

\begin{document}
\maketitle
\section{Design}
The goal of the project was to implement a program that checks for balanced
delimiters within a given file, using a stack-based approach to track that
each right-delimiter matched its corresponding left-delimiter. Of note, the
project instructions state the following:
\begin{displayquote}
It should
then repeatedly call the method that returns the next character until it returns a null character
indicating the end of the file or until a mismatch of delimiters is encountered. If the character is a
left delimiter it should be pushed onto a delimiter stack. If it is a right delimiter, the stack should
be popped and a check should be made to ensure that the delimiters are of a matching type. If the
delimiters do not match, a message should be displayed indicating what delimiter was
encountered and at what position.
\end{displayquote}
This can cause confusion when dealing with extraneous delimiters, as the
instructions state that every time a right-delimiter is encountered,
the stack should be popped, removing the last left-delimiter. In the case of
an extraneous right-delimiter, a potentially valid left-delimiter and
right-delimiter pair would not be matched if an extra right-delimiter is
encountered.

The following code snippet illustrates the potential issue:
\begin{verbatim}
line 1: public class badExample {
line 2:   ) // Bad delimiter
line 3: } // Unmatched good delimiter
\end{verbatim}
Using this code snippet, following the project requirements as written,
the program will display an error message indicating that an unmatched
right-delimiter was encountered at line 3, position 1. This is actually
incorrect, as the actual problem is that there is an unmatched left-delimiter
at line 2, position 3.

\subsection{UML Diagram}
\includesvg{CheckDelimiters-Class.svg}
\section{Test Plan}
Test Plan:
\begin{itemize}
    \item Test 1: Invalid filename provided ; program should display an error
    message indicating that the file does not exist, and re-prompt the user
    for a filename.
    \item Test 2: Valid input with matching delimiters ; Several delimiters
    are included in the input file, \emph{goodfile.java}, both inside and outside of
    comments. The program should correctly identify and match all delimiters,
    and not display any error messages.  The program should especially not
    display any error messages related to unmatched delimiters inside of
    comments.
    \item Test 3: Valid input with mismatched delimiters ; a total of
    six (6) mismatched delimiters are included in the input file,
    \emph{badfile1.java}. The program should correctly identify and report
    all mismatched delimiters, and not display any error messages related
    to unmatched delimiters inside of comments.
    \item Test 4: Valid input, \emph{badfile2.java} with an extraneous
    left-delimiter, as well as a left-delimiter inside a comment.  The program
    should correctly identify and report the single left-delimiter.
    \item Test 5: Valid input, \emph{badfile3.java} with an extraneous
    right-delimiter, as well as a right-delimiter inside a comment.  The
    program should correctly identify and report the bad right-delimiter,
    as well as the right-delimiter that would normally be matched at the end
    of the file.
\end{itemize}
Results are displayed in Table \ref{tab:test-plan}. Test data is provided in
Section \ref{sec:test-data}.
\begin{table}[h]
\centering
\caption{Test Results}
\begin{tabulary}{1.0\textwidth}{RLL}
\toprule
Test Case & Input & Expected Output \\
\cmidrule(l){1-1} \cmidrule(lr){2-2} \cmidrule(l){3-3}
1 & Invalid filename & Message displays that the file does not exist, and
    re-prompt the user for the filename. \\
\\
2 & Valid input with matching delimiters, file: goodfile.java & No error
message, program completes successfully and displays ``End of file reached." \\
\\
3 & Invalid input with mismatched left-delimiters, file: badfile1.java &
Program displays error
messages for each mismatched delimiter.\newline
Unmatched right delimiter `)' found at line 11, character (index) 41.\newline
Unmatched right delimiter `]' found at line 15, character (index) 44.\newline
Unmatched right delimiter `]' found at line 26, character (index) 7.\newline
Unmatched right delimiter `)' found at line 33, character (index) 3.\newline
Unmatched right delimiter `\}' found at line 35, character (index) 3.\newline
Unmatched right delimiter `\}' found at line 36, character (index) 1. \\
\\
4 & Invalid input with mismatched right-delimiters, file: badfile2.java &
Program displays error messages for each mismatched delimiter. \newline
Unmatched right delimiter `\}' found at line 3, character (index) 1.\\
\\
5 & Invalid input with mismatched right-delimiters, file: badfile3.java &
Program displays error messages for each mismatched delimiter. \newline
Unmatched right delimiter `)' found at line 2, character (index) 3.\newline
Unmatched right delimiter `\}' found at line 3, character (index) 1.\\
\bottomrule
\end{tabulary}

\label{tab:test-plan}
\end{table}
\section{Lessons Learned}
The single most important lesson learned from the project was the importance
of reading the requirements carefully and thoroughly. When initially
creating the pseudocode framework of the project, this programmer initially
assumed that one should trap each individual delimiter, and not necesserily
pop a left-delimiter off of the stack if the next right-delimiter did not
match. This assumption would have increased the complexity of the code,
and would have discarded one of the requirements of the project, that
each time a right-delimiter was encountered, one \emph{must} pop the
left-delimiter off of the stack.

A second read through the requirements allowed the programmer to catch
this error in understanding, and correct the pseudocode before writing
the actual program.
\section{Test Data}
\label{sec:test-data}
\subsection{goodfile.java}
\begin{verbatim}
/*
 * multi-line comment
 */
public class goodfile {
  public static void main(String[] args) {
    // single-line comment
    // single-line comment
    // Initialize scanner to read from standard input
    Scanner scanner = new Scanner(System.in);
    while (reader == null) {
      System.out.print("Enter the name of the source file: ");
      String filename = scanner.nextLine();
      // Try to create a SourceFileReader object with the provided filename.
      // If the file is not found, catch the exception and prompt the user.
      try {
        reader = new SourceFileReader(filename);
      } catch (FileNotFoundException e) {
        System.out.println("File not found. Please enter a valid file name.");
      }
    }
}
  private static void mismatchedDelimiter(char character,
    String characterPosition) {
    // Print an error message indicating the unmatched right-delimiter and
    // its position.
    System.out.println("Unmatched right delimiter '" + character +
    "' found at " + characterPosition);
  }
  private static boolean isMatchingType(char leftDelimiter,
    char rightDelimiter) {
    /*
    Long comment explaining the purpose of the method and its parameters.
    */
    switch(leftDelimiter) {
      case '(':
        return (rightDelimiter == ')');
      case '{':
        return (rightDelimiter == '}');
      case '[':
        return (rightDelimiter == ']');
      default:
        return false;
    }
  }
  private static boolean isRightDelimiter(char rightDelimiter) {
    /*
     If character is (, {, or [, return true, otherwise return false.
     As with isMatchingType, this could get consolidated into a single return
     statement, but is expanded into a switch for clarity.
    */
  }
\end{verbatim}
\subsection{badfile1.java}
\begin{verbatim}
/*
 * multi-line comment
 */
public class badfile1 {
  public static void main(String[] args)) { // Bad delimiter )
    // single-line comment )
    // single-line comment
    // Initialize scanner to read from standard input
    Scanner scanner = new Scanner(System.in]; // Bad delimiter ]
    while (reader == null) {
      System.out.print("Enter the name of the source file: ");
      String filename = scanner.nextLine();
      // Try to create a SourceFileReader object with the provided filename}.
      // If the file is not found, catch the exception and prompt the user.
      try {
        reader = new SourceFileReader(filename);
      } catch (FileNotFoundException e) {
        System.out.println("File not found. Please enter a valid file name.");
      ] // Bad delimiter ]
    }
}
  private static void mismatchedDelimiter(char character,
    String characterPosition) {
    // Print an error message indicating the unmatched right-delimiter and
    // its position. [
    System.out.println("Unmatched right delimiter '" + character +
      "' found at " + characterPosition);
  ) // Bad delimiter )
  }
}
\end{verbatim}
\subsection{badfile2.java}
\begin{verbatim}
public class badfile2 {
  [ // Bad delimiter
} // Unmatched good delimiter
\end{verbatim}
\subsection{badfile3.java}
\begin{verbatim}
public class badfile3 {
  ) // Bad delimiter
} // Unmatched good delimiter
\end{verbatim}
\end{document}
